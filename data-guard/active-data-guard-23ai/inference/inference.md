# AI Inference and Vector Search on the Standby Database

## Introduction

In this lab you will run Generative AI inference into an Oracle Database environment by importing an ONNX model on the primary database and executing it on the physical standby database. Leveraging Real-Time Query and DML redirection features, we offload the resource-intensive workload of generating embeddings to the standby database while seamlessly inserting the results into the primary database. This approach provides a scalable and efficient method for embedding generation without impacting the performance or availability of the primary database.

You will learn how to load an ONNX model in Oracle, use SQL to invoke the model on standby, and utilize DML redirection to write inference results to the primary database.

By the end of this lab, you'll have a working example of an AI-enabled Oracle setup that decouples inference from data ingestion, demonstrating how Active Data Guard excels in offloading complex tasks from the primary database.


Estimated Lab Time: 15 Minutes

[Oracle Active Data Guard 23ai](videohub:1_fzrzvek5)

### Requirements
To try this lab, you must have completed the following labs:
* [Prepare the database hosts](../prepare-host/prepare-host.md)
* [Prepare the databases](../prepare-db/prepare-db.md)
* [Configure Data Guard](../configure-dg/configure-dg.md)
* [Verify the Data Guard configuration](../verify-dg/verify-dg.md)
* [Create role-based services](../create-services/create-services.md)

### Objectives

* Open the standby database and enable Real-Time Query
* Download a sample PDF and ONNX model.
* Load the document the primary database.
* Load the ONNX model on the primary database.
* Run embedding generation on the standby database.
* Run a vector search.

## Task 1: Open the standby database and enable Real-Time Query

1. From any terminal, connect to the standby database as SYSDBA.
    ```
    <copy>
    sql sys/WElcome123##@adghol_site1 as sysdba
    </copy>
    ```

2. Open the CDB and the PDB, then verify that the read-only service `MYPDB_RO` is started:
    ```
    <copy>
    alter database open;
    alter pluggable database MYPDB open;
    select name from v$active_services where con_name='MYPDB';
    </copy>
    ```

    ![Open the standby CDB and PDB](images/open-standby.png)

## Task 2: Download a sample PDF and ONNX model

1. On the primary database host `adghol0`, create the directory `$HOME/vector` and download the PDF and model:

    ```
    cd $HOME/vector
    wget https://www.oracle.com/a/tech/docs/adg-vs-storage-mirroring.pdf
    wget https://objectstorage.us-chicago-1.oraclecloud.com/n/idb6enfdcxbl/b/Livelabs/o/onnx-embedding-models/tinybert.onnx
    cd
    ```

## Task 3: Load the document on the primary database
1. Connect to the primary database to create the directory and configure the permissions:

    ```
    <copy>
    sql sys/WElcome123##@MYPDB_RW as sysdba
    </copy>
    ```

    ```
    <copy>
    CREATE OR REPLACE DIRECTORY vec_dump AS '/home/oracle/vector';
    GRANT READ ON DIRECTORY vec_dump TO tacuser;
    </copy>
    ```

2. Connect as `tacuser` user and create the supporting tables:
    ```
    <copy>
    CONNECT tacuser/WElcome123##@MYPDB_RW
    </copy>
    ```

    ```
    <copy>
    CREATE TABLE IF NOT EXISTS MY_BOOKS ( 
      id            INTEGER GENERATED BY DEFAULT ON NULL AS IDENTITY (START WITH 1 CACHE 20) PRIMARY KEY, 
      file_name     VARCHAR2(900), 
      file_size     INTEGER, 
      file_type     VARCHAR2(100), 
      file_content  BLOB
    );
    
    CREATE TABLE IF NOT EXISTS VECTOR_STORE (
      DOC_ID       NUMBER NOT NULL ENABLE, 
      EMBED_ID     NUMBER, 
      EMBED_DATA   VARCHAR2(4000), 
      EMBED_VECTOR VECTOR,
      FOREIGN KEY (DOC_ID) REFERENCES MY_BOOKS(ID)
    );
    </copy>
    ```

3. Insert the sample PDF document as a BLOB on the primary database:
    ```
    <copy>
    INSERT INTO my_books (file_name, file_size, file_type, file_content)
    VALUES (
      'adg-vs-storage-mirroring.pdf',
      DBMS_LOB.getlength(TO_BLOB(BFILENAME('VEC_DUMP', 'adg-vs-storage-mirroring.pdf'))),
      'PDF',
      TO_BLOB(BFILENAME('VEC_DUMP', 'adg-vs-storage-mirroring.pdf'))
    );

    COMMIT;
    <copy>
    ```

## Task 4: Load the ONNX model on the primary database

1. Still connected as `tacuser` on the primary database, load the model:
    ```
    <copy>
    EXEC DBMS_VECTOR.LOAD_ONNX_MODEL(
      'VEC_DUMP',
      'tinybert.onnx',
      'TINYBERT',
      JSON('{
        "function": "embedding",
        "embeddingOutput": "embedding",
        "input": {
          "input": ["DATA"]
        }
      }')
    );
    
    COMMIT;
    </copy>
    ```


## Task 5: Run embedding generation on the standby database.

1. Connect to the standby database and verify the model availability:

    ```
    <copy>
    sql tacuser/WElcome123##@MYPDB_RW
    </copy>
    ```

    ```
    <copy>
    SELECT MODEL_NAME, MINING_FUNCTION, ALGORITHM, ALGORITHM_TYPE,
       ROUND(MODEL_SIZE / 1024 / 1024) AS MB
    FROM   USER_MINING_MODELS;
    </copy>
    ```

2. Enable DML Redirection:
    ```
    <copy>
    ALTER SESSION ENABLE ADG_REDIRECT_DML;
    </copy>
    ```

3. Generate and insert the embeddings:

    ```
    <copy>
    DECLARE
      CURSOR c_embeddings IS
        SELECT dt.id AS doc_id, et.embed_id, et.text_chunk, et.embed_vector
        FROM my_books dt
        CROSS JOIN TABLE(
          dbms_vector_chain.utl_to_embeddings(
            dbms_vector_chain.utl_to_chunks(
              dbms_vector_chain.utl_to_text(dt.file_content),
              json('{"by":"words","max":"300","split":"sentence","normalize":"all"}')
            ),
            json('{"provider":"database", "model":"TINYBERT"}')
          )
        ) t
        CROSS JOIN JSON_TABLE(
          t.column_value,
          '$[*]' COLUMNS (
            embed_id     NUMBER          PATH '$.embed_id',
            text_chunk   VARCHAR2(4000)  PATH '$.embed_data',
            embed_vector CLOB            PATH '$.embed_vector'
          )
        ) et;
    
      v_row c_embeddings%ROWTYPE;
    
    BEGIN
      OPEN c_embeddings;
      LOOP
        FETCH c_embeddings INTO v_row;
        EXIT WHEN c_embeddings%NOTFOUND;
    
        -- Insert one row at a time
        INSERT INTO vector_store (doc_id, embed_id, embed_data, embed_vector)
        VALUES (v_row.doc_id, v_row.embed_id, v_row.text_chunk, v_row.embed_vector);
      END LOOP;
      CLOSE c_embeddings;
    END;
    /
    commit;
    </copy>
    ```

    **Note:** The generation would work as an INSERT .. SELECT on the primary database. On the standby database, the `dbms_vector_chain.utl_to_embeddings` procedure returns a type `VARRAY_VECTOR_T` which is not yet supported by DML redirection. For that reason you see a separation of vector generation and insertion in a PL/SQL block.

## Task 6: Verify the inserted vectors

    ```
    <copy>
    SELECT vector_serialize(embed_vector) FROM vector_store;
    </copy>
    ```

- **Author** - Ludovico Caldara, Product Manager Data Guard, Active Data Guard and Flashback Technologies
- **Contributors** - Robert Pastijn;
- **Last Updated By/Date** -  Ludovico Caldara, July 2025
